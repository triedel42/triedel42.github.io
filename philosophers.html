<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>triedel's 42 Notebook</title>
  <link rel="icon" href="favicon.ico" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styling.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title"><a href="index.html">triedel's 42 Notebook</a></h1>
<p class="subtitle">"Mostly useless"</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#philosophers" id="toc-philosophers">Philosophers</a>
<ul>
<li><a href="#resources" id="toc-resources">Resources</a></li>
<li><a href="#allowed-functions" id="toc-allowed-functions">Allowed
functions</a></li>
<li><a href="#threads" id="toc-threads">Threads</a></li>
<li><a href="#the-problem-with-sharing-forks"
id="toc-the-problem-with-sharing-forks">The problem with sharing
forks</a>
<ul>
<li><a href="#race-conditionswiki-race"
id="toc-race-conditionswiki-race">Race conditions</a></li>
<li><a href="#mutexeswiki-mutex"
id="toc-mutexeswiki-mutex">Mutexes</a></li>
</ul></li>
<li><a href="#the-problem-with-waiting-for-forks"
id="toc-the-problem-with-waiting-for-forks">The problem with waiting for
forks</a>
<ul>
<li><a href="#the-arbitrator-solution-unfeasible"
id="toc-the-arbitrator-solution-unfeasible">The arbitrator solution
(unfeasible)</a></li>
<li><a href="#the-resource-hierarchy-solution"
id="toc-the-resource-hierarchy-solution">The Resource hierarchy
solution</a></li>
</ul></li>
<li><a href="#moral-philosophy" id="toc-moral-philosophy">Moral
philosophy</a></li>
<li><a href="#text-output" id="toc-text-output">Text output</a></li>
<li><a href="#program-outline" id="toc-program-outline">Program
outline</a>
<ul>
<li><a href="#shared-memory" id="toc-shared-memory">Shared
memory</a></li>
<li><a href="#finding-the-dead---and-killing-them"
id="toc-finding-the-dead---and-killing-them">Finding the dead - and
killing them</a></li>
<li><a href="#ending-the-program" id="toc-ending-the-program">Ending the
program</a></li>
<li><a href="#error-handling" id="toc-error-handling">Error
handling</a></li>
</ul></li>
</ul></li>
<li><a href="#bonus" id="toc-bonus">Bonus</a>
<ul>
<li><a href="#new-functions" id="toc-new-functions">New
functions</a></li>
<li><a href="#semaphores" id="toc-semaphores">Semaphores</a></li>
<li><a href="#monitoring" id="toc-monitoring">Monitoring</a>
<ul>
<li><a href="#mis-using-semaphores"
id="toc-mis-using-semaphores">(Mis-)Using Semaphores</a></li>
<li><a href="#am-i-dead-yet" id="toc-am-i-dead-yet">Am I dead
yet?</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="philosophers">Philosophers</h1>
<blockquote>
<p>“Have another drink,” said Trillian, “Enjoy yourself.” “Which?” said
Arthur, “the two are mutually exclusive.” - THG2G</p>
</blockquote>
<p>We are given a version of the <a
href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining
philosophers problem</a>.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a
href="https://nafuka11.github.io/philosophers-visualizer/">Philosophers
visualizer</a> (by <a
href="https://github.com/nafuka11/philosophers-visualizer?tab=readme-ov-file">nafuka11</a>)</li>
<li>Threads and Mutexes:
<ul>
<li><a href="https://hpc-tutorials.llnl.gov/posix/">POSIX Threads
Programming</a></li>
<li><a
href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1214/static/lectures/cs110-lecture-08-race-conditions-deadlock.pdf">Lecture
slides “Concurrency and Race Conditions”</a></li>
<li><a
href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1204/static/lectures/10-threads-and-mutexes.pdf">Lecture
slides “Threads and mutexes”</a></li>
</ul></li>
<li>Semaphores (Bonus)
<ul>
<li><a
href="https://pages.cs.wisc.edu/~remzi/Classes/537/Fall2008/Notes/threads-semaphores.txt">Semaphore
explanation and examples (plaintext)</a></li>
<li><a
href="https://www.man7.org/linux/man-pages/man7/sem_overview.7.html">Semaphores
man page</a></li>
</ul></li>
<li>On the “<a
href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining
Philosopher’s problem</a>:
<ul>
<li><a
href="https://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF">Dijkstra’s
Dining Philosopher’s Problem</a> (p. 20)</li>
<li><a href="http://www.usingcsp.com/cspbook.pdf">Communicating
Sequential Processes</a>: Tony Hoare’s version (Chapter 2.5, p. 55)</li>
</ul></li>
</ul>
<hr />
<h2 id="allowed-functions">Allowed functions</h2>
<ul>
<li>old friends: <a
href="https://www.man7.org/linux/man-pages/man3/memset.3.html"><code>memset</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/printf.3.html"><code>printf</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/malloc.3.html"><code>malloc</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/free.3.html"><code>free</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man2/write.2.html"><code>write</code></a></li>
<li>timing: <a
href="https://www.man7.org/linux/man-pages/man3/usleep.3.html"><code>usleep</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man2/gettimeofday.2.html"><code>gettimeofday</code></a></li>
<li>new enemies: <a
href="https://www.man7.org/linux/man-pages/man3/pthread_create.3.html"><code>pthread_create</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/pthread_detach.3.html"><code>pthread_detach</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/pthread_join.3.html"><code>pthread_join</code></a></li>
<li>mutex: <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_init</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_destroy</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html"><code>pthread_mutex_lock</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html"><code>pthread_mutex_unlock</code></a></li>
</ul>
<h2 id="threads">Threads</h2>
<p>Since this project is about learning to use threads, let’s start <a
href="https://en.wikipedia.org/wiki/Thread_(computing)">there</a>.</p>
<p>A <a
href="https://en.wikipedia.org/wiki/Thread_(computing)">thread</a> is
like a process in that it runs <a
href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrently</a>
with other threads. It is unlike a process in that it shares its memory
and even the program binary with other threads.</p>
<p>Creating threads is straightforward. We only need a function that
takes and returns a void pointer:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* This is the code that our thread will run */</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span>    <span class="op">*</span>threadfun<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>args<span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m a thread</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>NULL<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    pthread_t   thread<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Thread will call threadfun */</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    pthread_create<span class="op">(&amp;</span>thread<span class="op">,</span> NULL<span class="op">,</span> threadfun<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Wait for thread to finish */</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    pthread_join<span class="op">(</span>thread<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can also pass on to the thread a pointer to some shared memory
(<code>args</code>). We will need this later.</p>
<h2 id="the-problem-with-sharing-forks">The problem with sharing
forks</h2>
<p>You might wonder what the big deal is with this project. After all,
why not just have a boolean for each fork where <code>true</code> means
“available” and <code>false</code> means taken?</p>
<p>Here is what might happen in our case:</p>
<pre><code>philosopher 1 sees that fork 2 is free   (reading state of fork 2)
philosopher 2 sees that fork 2 is free   (reading state of fork 2)
philosopher 1 sets fork 2 as taken       (writing state of fork 2)
philosopher 2 sets fork 2 as taken       (writing state of fork 2)</code></pre>
<p>After this, <em>both</em> philosophers are in possession of the
<em>same fork</em>. We have created a <a
href="https://en.wikipedia.org/wiki/Race_condition">race
condition</a>.</p>
<p>The same scenario could have played out like this and all would have
been “fine”.</p>
<pre><code>philosopher 1 sees that fork 2 is free   (reading state of fork 2)
philosopher 1 sets fork 2 as taken       (writing state of fork 2)
philosopher 2 sees that fork 2 is taken  (reading state of fork 2)</code></pre>
<p>We do not want our program to depend on coincidence, therefore we
will make use of <a
href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutual
exclusions</a>, mutex for short.</p>
<h3 id="race-conditionswiki-race"><a
href="https://en.wikipedia.org/wiki/Race_condition">Race
conditions</a></h3>
<blockquote>
<p>“A race condition is an unpredictable ordering of events (due to
e.g. OS scheduling) where some orderings may cause undesired behavior.”
- <a
href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1214/static/lectures/cs110-lecture-08-race-conditions-deadlock.pdf">cs110-08</a></p>
</blockquote>
<p>In our code we have so-called <a
href="https://en.wikipedia.org/wiki/Critical_section"><strong>critical
sections</strong></a> like the reading and writing of the fork state
before. A critical section is indivisible in that it must not be
interrupted by another thread. If it is, we might have a <a
href="https://en.wikipedia.org/wiki/Race_condition"><strong>race
condition</strong></a>. To <em>ensure</em> that it isn’t interrupted we
can make it <strong>atomic</strong>. Locking a <a
href="https://en.wikipedia.org/wiki/Mutual_exclusion"><strong>mutex</strong></a>
before and unlocking it after our critical section does that with
respect to code that also locks the same mutex. If we protect critical
sections in this way we avoid race conditions.</p>
<p>We always should consider the implications when memory is not only
<em>shared</em>, but <em>accessed</em> concurrently. While it’s not a
problem when several threads read from the same value, reading
<em>and</em> writing from different threads easily generates these
problems.</p>
<h3 id="mutexeswiki-mutex"><a
href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutexes</a></h3>
<p>Mutexes are a way to ensure that a resource like a fork (commonly
memory) are only in use by one thread at a time. For this we call <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html"><code>pthread_mutex_lock</code></a>.
If the resource is free, we take it and lock it so that nobody else can
interfere. If it isn’t, <code>pthread_mutex_lock</code> blocks (waits)
until it is. In either case after <code>pthread_mutex_lock</code>
returns (without error) we are in possession of the resource. Once we’re
done, we <code>pthread_mutex_unlock</code> the resource.</p>
<p>The fact that <code>pthread_mutex_lock</code> might block means we
should use Mutexes sparingly. There is also
<code>pthread_mutex_trylock</code>, wich comes without that
disadvantage, but we’re not allowed to use it.</p>
<h2 id="the-problem-with-waiting-for-forks">The problem with waiting for
forks</h2>
<p>Here’s another potential problem that arises, even when the forks are
protected with mutexes. Imagine you have two philosophers and two forks
on the table. They each start eating at the same time, both starting by
picking up their left fork.</p>
<p>Here “waits for fork” means locking the mutex that protects the
fork.</p>
<pre><code>Philosopher 1 takes fork 1
Philosopher 2 takes fork 2
Philosopher 1 waits for fork 2, philosopher 2 waits for fork 1</code></pre>
<p>Now the philosophers will starve to death, each holding one fork and
waiting for the other.</p>
<p>This is called a <a
href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>, which
apparently is what the <a
href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">original
Dining philosopher’s problem</a> is mostly concerned with. There are
multiple solutions to that problem, two of which I believe are relevant
for us.</p>
<h3 id="the-arbitrator-solution-unfeasible">The arbitrator solution
(unfeasible)</h3>
<p>I find the <a
href="https://en.wikipedia.org/wiki/Dining_philosophers_problem#Arbitrator_solution">arbitrator
solution</a> easiest.</p>
<p>The issue - as before - was that taking the forks isn’t
<em>atomic</em> (uninterruptible). Deadlocks from taking only one fork
are undesired behavior, the taking of forks therefore is a <em>critical
section</em>. We can <em>make</em> that section atomic by again using a
mutex (the waiter). With that change philosopher’s aren’t allowed to
take forks</p>
<pre><code>Philosopher 1 asks waiter for both forks
Philosopher 1 picks up forks
Philosopher 2 asks waiter for both forks (but has to wait)
Philosopher 1 releases the forks
Philosopher 2 picks up forks
...</code></pre>
<p>However, the blocking nature of our only available
<code>pthread_mutex_lock</code> means that asking for currently taken
forks keeps far away philosophers from doing the same with unrelated
forks, because the “waiter is busy”. I don’t think, therefore, that this
is solution is feasible.</p>
<h3 id="the-resource-hierarchy-solution">The Resource hierarchy
solution</h3>
<p>If we <a
href="https://en.wikipedia.org/wiki/Dining_philosophers_problem#Resource_hierarchy_solution">order
our forks from lowest to highest</a> and always start by taking the
lowest fork, we have also prevented deadlocks. It is like having one
left-handed philosopher at the table, who unlike the others, starts with
the other fork.</p>
<p>This method of course has the disadvantage that taking only one fork
at a time is still possible, but we will have to contend with that.</p>
<h2 id="moral-philosophy">Moral philosophy</h2>
<p>How does a good philosopher behave? Good meaning his actions make the
simulation run as long as possible.</p>
<blockquote>
<p>When a philosopher has finished eating, they put their forks back on
the table and start sleeping. Once awake, they start thinking again.</p>
</blockquote>
<p>Hence the order of the actions is given as
<code>eat, sleep, think</code>. We could start with either one.</p>
<p>Remember though that no communication is allowed between them. If
possible, we want them to behave in a coodinated way without the
<em>need</em> even to communicate.</p>
<h2 id="text-output">Text output</h2>
<p>Have you noticed this line in the subject?</p>
<blockquote>
<p>A displayed state message should not be mixed up with another
message</p>
</blockquote>
<p>It’s not explicit, but I suppose we should regard outputting text as
a resource as well. <em>Outputting</em> is something that only one
thread at a time should do, or our output might be mangled by
<code>printf</code>s interrupting each other. We should use a mutex for
locking the output too.</p>
<p>While the Linux implementation of <code>printf</code> may be
thread-safe, the C standard as far as I know makes no such
guarantee.</p>
<h2 id="program-outline">Program outline</h2>
<p>With all this at our disposal it becomes clearer what our program
must look like.</p>
<p>Let’s translate our task: Philosophers are threads, forks are
mutex-protected booleans. Eating is waiting with a fork, thinking and
sleeping are doing so without.</p>
<ol type="1">
<li>Process arguments</li>
<li>Initialize, set up Mutexes, allocate memory</li>
<li>Start philosopher threads</li>
<li>Have the threads lock and unlock mutexes and wait as needed</li>
<li>Monitor shared memory for dead philosophers or error</li>
<li>Join threads, destroy mutexes and exit</li>
</ol>
<h3 id="shared-memory">Shared memory</h3>
<p>What information do we pass on to the thread? A thread must know the
program’s parameters, the simulation state and have access to the
mutexes. So I use a struct like this one and pass it onto the
threads.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* simulation struct */</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> s_sim</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* program parameters */</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             nphilos<span class="op">;</span>        <span class="co">/* total number of seats */</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             time_to_die<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             time_to_eat<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             time_to_sleep<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             must_eat<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* simulation state (SHARED) */</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             stopped<span class="op">;</span>        <span class="co">/* whether sim is active */</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             error<span class="op">;</span>          <span class="co">/* whether an error occurred */</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> timeval  start<span class="op">;</span>          <span class="co">/* timestamp of sim start */</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span>    philo_count<span class="op">;</span>    <span class="co">/* currently seated philos */</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    t_philo         <span class="op">*</span>philos<span class="op">;</span>        <span class="co">/* philosopher structs */</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             <span class="op">*</span>forks<span class="op">;</span>         <span class="co">/* fork states */</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* threads */</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    pthread_t       <span class="op">*</span>threads<span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* mutexes */</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_t <span class="op">*</span>mt_forks<span class="op">;</span>      <span class="co">/* forks */</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_t mt_count<span class="op">;</span>       <span class="co">/* incrementing philo_count */</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_t mt_eat<span class="op">;</span>         <span class="co">/* protect eating and stopped state */</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    pthread_mutex_t mt_output<span class="op">;</span>      <span class="co">/* stdout */</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>   t_sim<span class="op">;</span></span></code></pre></div>
<p><code>t_philo</code> looks like this, where <code>t_activity</code>
is a simple <code>enum</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* philosopher struct */</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> s_philo</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>             id<span class="op">;</span>             <span class="co">/* id from 0 to n - 1 */</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span>    meals_eaten<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> timeval  last_eaten<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    t_activity      act<span class="op">;</span>            <span class="co">/* activity enum (e.g. EAT=0) */</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>   t_philo<span class="op">;</span></span></code></pre></div>
<p>Now this part we have to think very carefully about. We have memory
shared among the threads. So which thread changes which memory? One by
one, let’s make sure there is no race condition.</p>
<ul>
<li><p><code>stopped</code>: This variable is only ever set from
<code>0</code> to <code>1</code>. Interspersed reads and writes have the
same effect, so all good.</p></li>
<li><p><code>error</code>: same as above</p></li>
<li><p><code>start</code>: Written by main thread once, only read by
philosopher threads after</p></li>
<li><p><code>philo_count</code>: <em>Incremented</em> when a new
philosopher thread starts. Yup, that’s a problem! Mutex
<code>mt_count</code> to the rescue!</p></li>
<li><p><code>philos</code>: Each thread only reads and writes to their
part of the array. <em>However</em>, we will read this from the main
thread to stop the simulation, creating a race condition. The critical
sections are</p>
<ul>
<li><code>main reads last_eaten; main writes stopped</code></li>
<li><code>philo reads stopped; philo writes last_eaten</code>.</li>
</ul></li>
<li><p><code>forks</code>: Accessed from all philosophers, protected by
<code>mt_forks</code>.</p>
<p>If not protected by a mutex, a dead philosopher could end up eating -
that’s impossible. Let’s have an <code>mt_eat</code> mutex protecting
those sections.</p></li>
</ul>
<h4 id="who-even-am-i">Who even am I?</h4>
<p>In order to make sure that each philosopher is an individual - with
their own <code>id</code> - and <code>id</code>s only exists once, we
need mutexes. When a philosopher thread starts it increments the global
<code>philo_count</code>. And incrementing shared values is done with
mutexes.</p>
<p>Here <code>errset(t_sim *s, status)</code> sets
<code>sim-&gt;error</code> if <code>status</code> is nonzero (see <a
href="#error-handling">error handling</a>).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> philo_whoami<span class="op">(</span>t_sim <span class="op">*</span>sim<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>errset<span class="op">(</span>sim<span class="op">,</span> pthread_mutex_lock<span class="op">(&amp;</span>sim<span class="op">-&gt;</span>count<span class="op">)))</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>ERR<span class="op">);</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    sim<span class="op">-&gt;</span>philo_count<span class="op">++;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>errset<span class="op">(</span>sim<span class="op">,</span> pthread_mutex_unlock<span class="op">(&amp;</span>sim<span class="op">-&gt;</span>count<span class="op">)))</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>ERR<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ids range from 0 to philo_count - 1</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>sim<span class="op">-&gt;</span>philo_count <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Alternatively we might increment the value before starting the thread
and give each philosopher their own slice of memory (including the
shared <code>t_sim</code> struct). However then we’d have to worry about
more allocations or variable scope.</p>
<h4 id="the-purely-self-interested-philosopher">The purely
Self-interested philosopher</h4>
<p>Only think if necessary and grab the forks first chance you get,
would be the simplest routine for a philosopher. However, this means he
will take a fork away from a starving neighbor. For only two philosopher
this solution is still viable.</p>
<h4 id="the-self-aware-philosopher">The self-aware philosopher</h4>
<p>Can we do better? A philosopher could delay taking the forks to give
those with less time left a chance. A good philosopher will make sure
that both his neighbors have had time to eat before he eats again. He
ensures this by prolonging his thinking until his time of not having the
forks (<code>time_to_sleep</code> + time spent thinking) is bigger than
<code>time_to_eat + some_margin</code>. That was enough for me to make
the simulation run well enough in all cases. Some empathy goes a long
way!</p>
<h3 id="finding-the-dead---and-killing-them">Finding the dead - and
killing them</h3>
<blockquote>
<p>A message announcing a philosopher died should be displayed no more
than 10 ms after the actual death of the philosopher.</p>
</blockquote>
<p>How do we do that?</p>
<p>In the memory that is shared with the threads we keep a record of
each philosopher’s last meal time. We check continuously and as soon as
we notice that it’s more than <code>time_to_die</code> milliseconds in
the past we write a message and exit the program.</p>
<p>This does not create a race condition, because each thread only
writes to their respective philosopher’s meal time and we only read it
from the original thread.</p>
<p>Here is what the main thread might look like.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* This runs in the main thread */</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>check_if_starved<span class="op">(</span>philosopher<span class="op">)</span> <span class="op">||</span> simulation_ended<span class="op">(</span>sim<span class="op">))</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    usleep<span class="op">(</span><span class="dv">1000</span><span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>announce_dead<span class="op">(</span>philosopher<span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">/* end simulation, clean up and exit */</span></span></code></pre></div>
<h3 id="ending-the-program">Ending the program</h3>
<p>Once we have found a starved philosopher, we have to tell him that he
starved - no really - by killing the thread. The <a
href="https://www.man7.org/linux/man-pages/man3/pthread_create.3.html">man
page of <code>pthread_create</code></a> tells us the ways a thread can
exit. We here can unfortunately only kill a thread by returning from
<code>main()</code>. That’s unfortunate, because before doing so we need
to destroy the mutexes and deallocate memory while the threads continue
to operate on them.</p>
<p>Alternatively we could politely ask the philosophers to please die
and only clean up once they obliged. A simple <code>bool</code> flag
like <code>simulation_ended</code> would be enough. This is in shared
memory yes, we’ll make sure nothing goes wrong later.</p>
<p>What if a philosopher is in the process of waiting for a mutex? How
do we wake him up? Well a thinking philosopher will be interrupted by
giving him the fork. The block from <code>pthread_mutex_lock</code> is
gone. When their neighbours are dead, they will get it. Easy enough.</p>
<p>A sleeping or eating philosopher has to interrupt themselves. We can
of course divide up a <code>usleep(time_to_sleep)</code> like so to make
them respect the end of a simulation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(!</span>simulation_ended <span class="op">&amp;&amp;</span> <span class="op">!</span>finished_sleeping<span class="op">())</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    usleep<span class="op">(</span><span class="dv">1000</span><span class="op">);</span></span></code></pre></div>
<p>Does this mess up the timing? A bit, we can mitigate this by
measuring everything in microseconds. But ultimately there will be some
extra delay.</p>
<h3 id="error-handling">Error handling</h3>
<p>Most functions like the mutex locking and unlocking return a value
that indicates potential failure. How do we deal with failure? I see two
options. You either exit with leaks and say it’s okay, because it’s an
exception or you indicate an error in the shared memory and wait for
every thread to recognize it and exit.</p>
<p>I prefer the latter, because it makes sure to free all the
resources.</p>
<h1 id="bonus">Bonus</h1>
<h2 id="new-functions">New functions</h2>
<ul>
<li><a
href="https://www.man7.org/linux/man-pages/man2/fork.2.html"><code>fork</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man2/kill.2.html"><code>kill</code></a>,
<a
href="https://www.man7.org/linux/man-pages/man3/exit.3.html"><code>exit</code></a>
and <a
href="https://www.man7.org/linux/man-pages/man2/waitpid.2.html"><code>waitpid</code></a>
join the party.</li>
<li>semaphore handling: <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_open.html"><code>sem_open</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_close.html"><code>sem_close</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_post.html"><code>sem_post</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_wait.html"><code>sem_wait</code></a>,
<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_unlink.html"><code>sem_unlink</code></a></li>
</ul>
<h2 id="semaphores">Semaphores</h2>
<blockquote>
<p>“A semaphore is an integer whose value is never allowed to fall below
zero” - <a
href="https://www.man7.org/linux/man-pages/man7/sem_overview.7.html"><code>sem_overview</code></a></p>
</blockquote>
<p>Besides <a
href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutexes</a>, which
we’ve used in the mandatory part, <a
href="https://en.wikipedia.org/wiki/Semaphore_(programming)">semaphores</a>
are another way to synchronize concurrent programs and avoid race
conditions. Semaphores are like your bank account. If you want to spend
(<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_wait.html"><code>sem_wait</code></a>)
something, you first need to deposit (<a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_post.html"><code>sem_post</code></a>)
it.</p>
<p>The name derives from train signals where a train is only free to
enter a section of track when a semaphore signals it. This is much the
same for us. Our code is only free to enter a <em>critical section</em>
when not too many threads are already inside it.</p>
<p>You can think of semaphores like a “resource count”, presupposing
that those resources can be used interchangeably. Our forks are in the
<em>middle</em> of the table, within reach of everybody, and so are
interchangeable.</p>
<p>The use of semaphores in our case is rather simple. We use it of
course as the number of available forks like so:</p>
<ol type="1">
<li>Create a named semaphore with <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_open.html"><code>sem_open</code></a>
and initialize it to number of forks</li>
<li>Use <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_wait.html"><code>sem_wait</code></a>
for taking forks and <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_post.html"><code>sem_post</code></a>
when returning</li>
<li><a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_close.html"><code>sem_close</code></a>
it from each process, then <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_unlink.html"><code>sem_unlink</code></a>
from the main process.</li>
</ol>
<p>Normally one can also read the value of a semaphore with <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_getvalue.html"><code>sem_getvalue</code></a>.
But we don’t even need the value. As long as forks are returned at
<em>some</em> point, there is no danger of deadlocks.</p>
<h2 id="monitoring">Monitoring</h2>
<p>The only means of inter-process communication we have is <a
href="https://www.man7.org/linux/man-pages/man2/kill.2.html"><code>kill</code></a>.
But without <a
href="https://www.man7.org/linux/man-pages/man2/sigaction.2.html"><code>sigaction</code></a>
that’s of no use. So then the problem I see is how does the main process
recognize starving processes, since the processes themselves will be
stuck in <a
href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_wait.html"><code>sem_wait</code></a>?
Well, threads again I suppose. Blocking is a good reason to use another
thread.</p>
<h3 id="mis-using-semaphores">(Mis-)Using Semaphores</h3>
<p>We can also use semaphores as a form of inter-process communication.
The sender calls <code>sem_post</code> while the recipient calls
<code>sem_wait</code>. This comes in handy to keep track of the number
of hungry (meaning <code>times_a_philosopher_has_to_eat &gt; 0</code>)
philosophers. Calling <code>sem_post</code> after receiving a signal
also enables us to have multiple recipients, which is useful as a global
<code>/exit</code> signal.</p>
<h3 id="am-i-dead-yet">Am I dead yet?</h3>
<p>A philosopher can notice himself when he has starved. We are allowed
to use threads, so in parallel to each philosopher process we can have a
separate thread that checks if he is dead yet. To notify the other
philosophers of his early demise, we can publish a <code>/death</code>
message.</p>
<div style="height: 1500px; display: block"></div>
</body>
</html>
